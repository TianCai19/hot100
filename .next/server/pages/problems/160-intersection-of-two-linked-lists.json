{"pageProps":{"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    hr: \"hr\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    strong: \"strong\",\n    table: \"table\",\n    tbody: \"tbody\",\n    td: \"td\",\n    th: \"th\",\n    thead: \"thead\",\n    tr: \"tr\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {DifficultyBadge, Mermaid} = _components;\n  if (!DifficultyBadge) _missingMdxReference(\"DifficultyBadge\", true);\n  if (!Mermaid) _missingMdxReference(\"Mermaid\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"160. 相交链表\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.strong, {\n        children: [\"难度：\", _jsx(DifficultyBadge, {\n          children: \"简单\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"题目描述\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"给你两个单链表的头节点 \", _jsx(_components.code, {\n        children: \"headA\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"headB\"\n      }), \"，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 \", _jsx(_components.code, {\n        children: \"null\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"图示\"\n    }), \"\\n\", _jsx(Mermaid, {\n      children: _jsx(_components.p, {\n        children: \"graph LR\\nsubgraph 链表A\\nA1((a1)) --> A2((a2))\\nend\\nsubgraph 链表B\\nB1((b1)) --> B2((b2)) --> B3((b3))\\nend\\nsubgraph 公共部分\\nC1((c1)) --> C2((c2)) --> C3((c3))\\nend\\nA2 --> C1\\nB3 --> C1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"注意：\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"题目数据保证整个链式结构中不存在环\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"函数返回结果后，链表必须保持其原始结构\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"示例\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"示例 1\"\n    }), \"\\n\", _jsx(Mermaid, {\n      children: _jsx(_components.p, {\n        children: \"graph LR\\nA4((4)) --> A1((1)) --> C8((8)) --> C4((4)) --> C5((5))\\nB5((5)) --> B6((6)) --> B1((1)) --> C8\\nstyle C8 fill:#f96\\nstyle C4 fill:#f96\\nstyle C5 fill:#f96\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输入：\"\n        }), \" intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输出：\"\n        }), \" Intersected at '8'\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"解释：\"\n        }), \" 相交节点的值为 8。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"示例 2\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输入：\"\n        }), \" intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输出：\"\n        }), \" Intersected at '2'\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"示例 3\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输入：\"\n        }), \" intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输出：\"\n        }), \" No intersection\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"提示\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"listA 中节点数目为 m\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"listB 中节点数目为 n\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"1 <= m, n <= 3 * 10^4\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"1 <= Node.val <= 10^5\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"0 <= skipA <= m\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"0 <= skipB <= n\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      children: \"解法一：哈希集合\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"思路\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"用哈希集合存储链表 A 的所有节点，然后遍历链表 B，第一个在集合中出现的节点就是交点。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Python\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Solution\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getIntersectionNode\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"self, headA: ListNode, headB: ListNode\"\n        }), \") -> ListNode:\\n        visited = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"set\"\n        }), \"()\\n        curr = headA\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" curr:\\n            visited.add(curr)\\n            curr = curr.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"next\"\n        }), \"\\n\\n        curr = headB\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" curr:\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" curr \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" visited:\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" curr\\n            curr = curr.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"next\"\n        }), \"\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"None\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"C++\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Solution\"\n        }), \" {\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \":\\n    \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"ListNode *\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"getIntersectionNode\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(ListNode *headA, ListNode *headB)\"\n          }), \" \"]\n        }), \"{\\n        unordered_set<ListNode *> visited;\\n        ListNode *temp = headA;\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (temp != \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"nullptr\"\n        }), \") {\\n            visited.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"insert\"\n        }), \"(temp);\\n            temp = temp->next;\\n        }\\n        temp = headB;\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (temp != \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"nullptr\"\n        }), \") {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (visited.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"count\"\n        }), \"(temp)) {\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" temp;\\n            }\\n            temp = temp->next;\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"nullptr\"\n        }), \";\\n    }\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"复杂度分析\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"时间复杂度：\"\n        }), \" O(m + n)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"空间复杂度：\"\n        }), \" O(m)，需要存储链表 A 的所有节点\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      children: \"解法二：双指针（推荐）\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"思路\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"两个指针分别从 A 和 B 出发，走完自己的链表后走对方的链表。如果有交点，它们会在交点相遇；如果没有交点，它们会同时到达 null。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"原理：\"\n      }), \" 设链表 A 的独有部分长度为 a，链表 B 的独有部分长度为 b，公共部分长度为 c。\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"指针 pA 走的路径：a + c + b\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"指针 pB 走的路径：b + c + a\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"两者路径长度相等，必然同时到达交点或末尾。\"\n    }), \"\\n\", _jsx(Mermaid, {\n      children: _jsx(_components.p, {\n        children: \"graph TB\\nsubgraph 第一轮\\nPA1[pA: a1→a2→c1→c2→c3→null]\\nPB1[pB: b1→b2→b3→c1→c2→c3→null]\\nend\\nsubgraph 第二轮\\nPA2[pA: b1→b2→b3→c1相遇]\\nPB2[pB: a1→a2→c1相遇]\\nend\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"正确性证明\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"情况一：两个链表相交\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"若 a = b，两指针同时到达交点\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"若 a ≠ b，指针 pA 移动 a+c+b 次，pB 移动 b+c+a 次后相遇\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"情况二：两个链表不相交\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"若 m = n，两指针同时到达末尾变为 null\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"若 m ≠ n，两指针各移动 m+n 次后同时变为 null\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Python\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Solution\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getIntersectionNode\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"self, headA: ListNode, headB: ListNode\"\n        }), \") -> ListNode:\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" headA \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"or\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" headB:\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"None\"\n        }), \"\\n\\n        pA, pB = headA, headB\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" pA != pB:\\n            pA = pA.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"next\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" pA \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" headB\\n            pB = pB.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"next\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" pB \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" headA\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" pA\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"C++\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Solution\"\n        }), \" {\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \":\\n    \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"ListNode *\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"getIntersectionNode\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(ListNode *headA, ListNode *headB)\"\n          }), \" \"]\n        }), \"{\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!headA || !headB) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"nullptr\"\n        }), \";\\n\\n        ListNode *pA = headA, *pB = headB;\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (pA != pB) {\\n            pA = pA ? pA->next : headB;\\n            pB = pB ? pB->next : headA;\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" pA;\\n    }\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"复杂度分析\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"时间复杂度：\"\n        }), \" O(m + n)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"空间复杂度：\"\n        }), \" O(1)，只使用两个指针\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      children: \"两种解法对比\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"解法\"\n          }), _jsx(_components.th, {\n            children: \"时间复杂度\"\n          }), _jsx(_components.th, {\n            children: \"空间复杂度\"\n          }), _jsx(_components.th, {\n            children: \"优点\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"哈希集合\"\n          }), _jsx(_components.td, {\n            children: \"O(m+n)\"\n          }), _jsx(_components.td, {\n            children: \"O(m)\"\n          }), _jsx(_components.td, {\n            children: \"思路简单直观\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"双指针\"\n          }), _jsx(_components.td, {\n            children: \"O(m+n)\"\n          }), _jsx(_components.td, {\n            children: \"O(1)\"\n          }), _jsx(_components.td, {\n            children: \"空间最优\"\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"title":"160. 相交链表","difficulty":"简单"},"__N_SSG":true}