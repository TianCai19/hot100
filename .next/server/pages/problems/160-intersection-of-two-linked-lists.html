<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="preload" href="/_next/static/chunks/b9ef641e76e3a351.css" as="style"/><link rel="stylesheet" href="/_next/static/chunks/b9ef641e76e3a351.css" data-n-p=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/7b4bfea61b437e6c.js" defer=""></script><script src="/_next/static/chunks/7abe5c0b8e3d6f45.js" defer=""></script><script src="/_next/static/chunks/bb8bcfd910d27e02.js" defer=""></script><script src="/_next/static/chunks/turbopack-36b3b4bad9553227.js" defer=""></script><script src="/_next/static/chunks/87ccb4552dca3a5b.js" defer=""></script><script src="/_next/static/chunks/a20a8f7aa8204a0f.js" defer=""></script><script src="/_next/static/chunks/turbopack-b22aff4fabade535.js" defer=""></script><script src="/_next/static/rOLg3E_DLBfZoa8jF2pXF/_ssgManifest.js" defer=""></script><script src="/_next/static/rOLg3E_DLBfZoa8jF2pXF/_buildManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen bg-gray-900 text-gray-100"><nav class="bg-gray-800 border-b border-gray-700"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold text-blue-400 hover:text-blue-300" href="/">LeetCode Hot 100</a><div class="flex items-center gap-6"><a class="hover:text-blue-300 text-gray-300" href="/">题目列表</a><a href="https://leetcode.cn/problemset/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-gray-300">LeetCode</a></div></div></div></nav><main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><article class="max-w-4xl"><div class="mb-6"><button class="text-blue-400 hover:text-blue-300 flex items-center gap-2 mb-4"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>返回题目列表</button><h1 class="text-3xl font-bold text-blue-400 mb-2">160. 相交链表</h1><div class="flex items-center gap-3"><span class="px-3 py-1 text-sm rounded text-white bg-green-600">简单</span></div></div><div class="prose prose-invert prose-lg max-w-none"><h1 class="text-3xl font-bold text-blue-400 mb-6">160. 相交链表</h1>
<p class="text-gray-300 leading-relaxed mb-4"><strong>难度：<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium text-white bg-green-600">简单</span></strong></p>
<h2 class="text-2xl font-bold text-gray-200 mt-8 mb-4">题目描述</h2>
<p class="text-gray-300 leading-relaxed mb-4">给你两个单链表的头节点 <code class="bg-gray-800 px-1.5 py-0.5 rounded text-sm font-mono text-blue-300">headA</code> 和 <code class="bg-gray-800 px-1.5 py-0.5 rounded text-sm font-mono text-blue-300">headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code class="bg-gray-800 px-1.5 py-0.5 rounded text-sm font-mono text-blue-300">null</code>。</p>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">图示</h3>
<pre class="mermaid bg-gray-800 p-4 rounded-lg overflow-x-auto"><code><p class="text-gray-300 leading-relaxed mb-4">graph LR
subgraph 链表A
A1((a1)) --&gt; A2((a2))
end
subgraph 链表B
B1((b1)) --&gt; B2((b2)) --&gt; B3((b3))
end
subgraph 公共部分
C1((c1)) --&gt; C2((c2)) --&gt; C3((c3))
end
A2 --&gt; C1
B3 --&gt; C1</p></code></pre>
<p class="text-gray-300 leading-relaxed mb-4"><strong>注意：</strong></p>
<ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
<li class="ml-4">题目数据保证整个链式结构中不存在环</li>
<li class="ml-4">函数返回结果后，链表必须保持其原始结构</li>
</ul>
<h2 class="text-2xl font-bold text-gray-200 mt-8 mb-4">示例</h2>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">示例 1</h3>
<pre class="mermaid bg-gray-800 p-4 rounded-lg overflow-x-auto"><code><p class="text-gray-300 leading-relaxed mb-4">graph LR
A4((4)) --&gt; A1((1)) --&gt; C8((8)) --&gt; C4((4)) --&gt; C5((5))
B5((5)) --&gt; B6((6)) --&gt; B1((1)) --&gt; C8
style C8 fill:#f96
style C4 fill:#f96
style C5 fill:#f96</p></code></pre>
<ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
<li class="ml-4"><strong>输入：</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</li>
<li class="ml-4"><strong>输出：</strong> Intersected at &#x27;8&#x27;</li>
<li class="ml-4"><strong>解释：</strong> 相交节点的值为 8。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</li>
</ul>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">示例 2</h3>
<ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
<li class="ml-4"><strong>输入：</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</li>
<li class="ml-4"><strong>输出：</strong> Intersected at &#x27;2&#x27;</li>
</ul>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">示例 3</h3>
<ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
<li class="ml-4"><strong>输入：</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</li>
<li class="ml-4"><strong>输出：</strong> No intersection</li>
</ul>
<h2 class="text-2xl font-bold text-gray-200 mt-8 mb-4">提示</h2>
<ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
<li class="ml-4">listA 中节点数目为 m</li>
<li class="ml-4">listB 中节点数目为 n</li>
<li class="ml-4"><code class="bg-gray-800 px-1.5 py-0.5 rounded text-sm font-mono text-blue-300">1 &lt;= m, n &lt;= 3 * 10^4</code></li>
<li class="ml-4"><code class="bg-gray-800 px-1.5 py-0.5 rounded text-sm font-mono text-blue-300">1 &lt;= Node.val &lt;= 10^5</code></li>
<li class="ml-4"><code class="bg-gray-800 px-1.5 py-0.5 rounded text-sm font-mono text-blue-300">0 &lt;= skipA &lt;= m</code></li>
<li class="ml-4"><code class="bg-gray-800 px-1.5 py-0.5 rounded text-sm font-mono text-blue-300">0 &lt;= skipB &lt;= n</code></li>
</ul>
<hr/>
<h2 class="text-2xl font-bold text-gray-200 mt-8 mb-4">解法一：哈希集合</h2>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">思路</h3>
<p class="text-gray-300 leading-relaxed mb-4">用哈希集合存储链表 A 的所有节点，然后遍历链表 B，第一个在集合中出现的节点就是交点。</p>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">Python</h3>
<div class="relative group"><div class="absolute top-2 right-2 text-xs text-gray-400 opacity-0 group-hover:opacity-100 transition">text</div><pre class="language-text bg-gray-800 p-4 rounded-lg overflow-x-auto"><code><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:
        visited = <span class="hljs-built_in">set</span>()
        curr = headA
        <span class="hljs-keyword">while</span> curr:
            visited.add(curr)
            curr = curr.<span class="hljs-built_in">next</span>

        curr = headB
        <span class="hljs-keyword">while</span> curr:
            <span class="hljs-keyword">if</span> curr <span class="hljs-keyword">in</span> visited:
                <span class="hljs-keyword">return</span> curr
            curr = curr.<span class="hljs-built_in">next</span>

        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></code></pre></div>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">C++</h3>
<div class="relative group"><div class="absolute top-2 right-2 text-xs text-gray-400 opacity-0 group-hover:opacity-100 transition">text</div><pre class="language-text bg-gray-800 p-4 rounded-lg overflow-x-auto"><code><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{
        unordered_set&lt;ListNode *&gt; visited;
        ListNode *temp = headA;
        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) {
            visited.<span class="hljs-built_in">insert</span>(temp);
            temp = temp-&gt;next;
        }
        temp = headB;
        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) {
            <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">count</span>(temp)) {
                <span class="hljs-keyword">return</span> temp;
            }
            temp = temp-&gt;next;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    }
};
</code></code></pre></div>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">复杂度分析</h3>
<ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
<li class="ml-4"><strong>时间复杂度：</strong> O(m + n)</li>
<li class="ml-4"><strong>空间复杂度：</strong> O(m)，需要存储链表 A 的所有节点</li>
</ul>
<hr/>
<h2 class="text-2xl font-bold text-gray-200 mt-8 mb-4">解法二：双指针（推荐）</h2>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">思路</h3>
<p class="text-gray-300 leading-relaxed mb-4">两个指针分别从 A 和 B 出发，走完自己的链表后走对方的链表。如果有交点，它们会在交点相遇；如果没有交点，它们会同时到达 null。</p>
<p class="text-gray-300 leading-relaxed mb-4"><strong>原理：</strong> 设链表 A 的独有部分长度为 a，链表 B 的独有部分长度为 b，公共部分长度为 c。</p>
<ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
<li class="ml-4">指针 pA 走的路径：a + c + b</li>
<li class="ml-4">指针 pB 走的路径：b + c + a</li>
</ul>
<p class="text-gray-300 leading-relaxed mb-4">两者路径长度相等，必然同时到达交点或末尾。</p>
<pre class="mermaid bg-gray-800 p-4 rounded-lg overflow-x-auto"><code><p class="text-gray-300 leading-relaxed mb-4">graph TB
subgraph 第一轮
PA1[pA: a1→a2→c1→c2→c3→null]
PB1[pB: b1→b2→b3→c1→c2→c3→null]
end
subgraph 第二轮
PA2[pA: b1→b2→b3→c1相遇]
PB2[pB: a1→a2→c1相遇]
end</p></code></pre>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">正确性证明</h3>
<p class="text-gray-300 leading-relaxed mb-4"><strong>情况一：两个链表相交</strong></p>
<ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
<li class="ml-4">若 a = b，两指针同时到达交点</li>
<li class="ml-4">若 a ≠ b，指针 pA 移动 a+c+b 次，pB 移动 b+c+a 次后相遇</li>
</ul>
<p class="text-gray-300 leading-relaxed mb-4"><strong>情况二：两个链表不相交</strong></p>
<ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
<li class="ml-4">若 m = n，两指针同时到达末尾变为 null</li>
<li class="ml-4">若 m ≠ n，两指针各移动 m+n 次后同时变为 null</li>
</ul>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">Python</h3>
<div class="relative group"><div class="absolute top-2 right-2 text-xs text-gray-400 opacity-0 group-hover:opacity-100 transition">text</div><pre class="language-text bg-gray-800 p-4 rounded-lg overflow-x-auto"><code><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> headA <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> headB:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

        pA, pB = headA, headB

        <span class="hljs-keyword">while</span> pA != pB:
            pA = pA.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> pA <span class="hljs-keyword">else</span> headB
            pB = pB.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> pB <span class="hljs-keyword">else</span> headA

        <span class="hljs-keyword">return</span> pA
</code></code></pre></div>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">C++</h3>
<div class="relative group"><div class="absolute top-2 right-2 text-xs text-gray-400 opacity-0 group-hover:opacity-100 transition">text</div><pre class="language-text bg-gray-800 p-4 rounded-lg overflow-x-auto"><code><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{
        <span class="hljs-keyword">if</span> (!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;

        ListNode *pA = headA, *pB = headB;

        <span class="hljs-keyword">while</span> (pA != pB) {
            pA = pA ? pA-&gt;next : headB;
            pB = pB ? pB-&gt;next : headA;
        }

        <span class="hljs-keyword">return</span> pA;
    }
};
</code></code></pre></div>
<h3 class="text-xl font-semibold text-gray-200 mt-6 mb-3">复杂度分析</h3>
<ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
<li class="ml-4"><strong>时间复杂度：</strong> O(m + n)</li>
<li class="ml-4"><strong>空间复杂度：</strong> O(1)，只使用两个指针</li>
</ul>
<hr/>
<h2 class="text-2xl font-bold text-gray-200 mt-8 mb-4">两种解法对比</h2>
<div class="overflow-x-auto my-6"><table class="min-w-full divide-y divide-gray-700"><thead><tr><th class="px-6 py-3 bg-gray-800 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">解法</th><th class="px-6 py-3 bg-gray-800 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">时间复杂度</th><th class="px-6 py-3 bg-gray-800 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">空间复杂度</th><th class="px-6 py-3 bg-gray-800 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">优点</th></tr></thead><tbody><tr><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-300 border-b border-gray-700">哈希集合</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-300 border-b border-gray-700">O(m+n)</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-300 border-b border-gray-700">O(m)</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-300 border-b border-gray-700">思路简单直观</td></tr><tr><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-300 border-b border-gray-700">双指针</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-300 border-b border-gray-700">O(m+n)</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-300 border-b border-gray-700">O(1)</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-300 border-b border-gray-700">空间最优</td></tr></tbody></table></div></div></article></main><footer class="bg-gray-800 border-t border-gray-700 mt-16"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6"><p class="text-center text-gray-400">© 2025 LeetCode Hot 100 | Built with Next.js &amp; MDX</p></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    hr: \"hr\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    strong: \"strong\",\n    table: \"table\",\n    tbody: \"tbody\",\n    td: \"td\",\n    th: \"th\",\n    thead: \"thead\",\n    tr: \"tr\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {DifficultyBadge, Mermaid} = _components;\n  if (!DifficultyBadge) _missingMdxReference(\"DifficultyBadge\", true);\n  if (!Mermaid) _missingMdxReference(\"Mermaid\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"160. 相交链表\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.strong, {\n        children: [\"难度：\", _jsx(DifficultyBadge, {\n          children: \"简单\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"题目描述\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"给你两个单链表的头节点 \", _jsx(_components.code, {\n        children: \"headA\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"headB\"\n      }), \"，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 \", _jsx(_components.code, {\n        children: \"null\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"图示\"\n    }), \"\\n\", _jsx(Mermaid, {\n      children: _jsx(_components.p, {\n        children: \"graph LR\\nsubgraph 链表A\\nA1((a1)) --\u003e A2((a2))\\nend\\nsubgraph 链表B\\nB1((b1)) --\u003e B2((b2)) --\u003e B3((b3))\\nend\\nsubgraph 公共部分\\nC1((c1)) --\u003e C2((c2)) --\u003e C3((c3))\\nend\\nA2 --\u003e C1\\nB3 --\u003e C1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"注意：\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"题目数据保证整个链式结构中不存在环\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"函数返回结果后，链表必须保持其原始结构\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"示例\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"示例 1\"\n    }), \"\\n\", _jsx(Mermaid, {\n      children: _jsx(_components.p, {\n        children: \"graph LR\\nA4((4)) --\u003e A1((1)) --\u003e C8((8)) --\u003e C4((4)) --\u003e C5((5))\\nB5((5)) --\u003e B6((6)) --\u003e B1((1)) --\u003e C8\\nstyle C8 fill:#f96\\nstyle C4 fill:#f96\\nstyle C5 fill:#f96\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输入：\"\n        }), \" intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输出：\"\n        }), \" Intersected at '8'\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"解释：\"\n        }), \" 相交节点的值为 8。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"示例 2\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输入：\"\n        }), \" intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输出：\"\n        }), \" Intersected at '2'\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"示例 3\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输入：\"\n        }), \" intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"输出：\"\n        }), \" No intersection\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"提示\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"listA 中节点数目为 m\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"listB 中节点数目为 n\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"1 \u003c= m, n \u003c= 3 * 10^4\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"1 \u003c= Node.val \u003c= 10^5\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"0 \u003c= skipA \u003c= m\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"0 \u003c= skipB \u003c= n\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      children: \"解法一：哈希集合\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"思路\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"用哈希集合存储链表 A 的所有节点，然后遍历链表 B，第一个在集合中出现的节点就是交点。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Python\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Solution\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getIntersectionNode\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"self, headA: ListNode, headB: ListNode\"\n        }), \") -\u003e ListNode:\\n        visited = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"set\"\n        }), \"()\\n        curr = headA\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" curr:\\n            visited.add(curr)\\n            curr = curr.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"next\"\n        }), \"\\n\\n        curr = headB\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" curr:\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" curr \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" visited:\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" curr\\n            curr = curr.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"next\"\n        }), \"\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"None\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"C++\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Solution\"\n        }), \" {\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \":\\n    \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"ListNode *\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"getIntersectionNode\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(ListNode *headA, ListNode *headB)\"\n          }), \" \"]\n        }), \"{\\n        unordered_set\u003cListNode *\u003e visited;\\n        ListNode *temp = headA;\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (temp != \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"nullptr\"\n        }), \") {\\n            visited.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"insert\"\n        }), \"(temp);\\n            temp = temp-\u003enext;\\n        }\\n        temp = headB;\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (temp != \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"nullptr\"\n        }), \") {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (visited.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"count\"\n        }), \"(temp)) {\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" temp;\\n            }\\n            temp = temp-\u003enext;\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"nullptr\"\n        }), \";\\n    }\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"复杂度分析\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"时间复杂度：\"\n        }), \" O(m + n)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"空间复杂度：\"\n        }), \" O(m)，需要存储链表 A 的所有节点\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      children: \"解法二：双指针（推荐）\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"思路\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"两个指针分别从 A 和 B 出发，走完自己的链表后走对方的链表。如果有交点，它们会在交点相遇；如果没有交点，它们会同时到达 null。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"原理：\"\n      }), \" 设链表 A 的独有部分长度为 a，链表 B 的独有部分长度为 b，公共部分长度为 c。\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"指针 pA 走的路径：a + c + b\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"指针 pB 走的路径：b + c + a\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"两者路径长度相等，必然同时到达交点或末尾。\"\n    }), \"\\n\", _jsx(Mermaid, {\n      children: _jsx(_components.p, {\n        children: \"graph TB\\nsubgraph 第一轮\\nPA1[pA: a1→a2→c1→c2→c3→null]\\nPB1[pB: b1→b2→b3→c1→c2→c3→null]\\nend\\nsubgraph 第二轮\\nPA2[pA: b1→b2→b3→c1相遇]\\nPB2[pB: a1→a2→c1相遇]\\nend\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"正确性证明\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"情况一：两个链表相交\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"若 a = b，两指针同时到达交点\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"若 a ≠ b，指针 pA 移动 a+c+b 次，pB 移动 b+c+a 次后相遇\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"情况二：两个链表不相交\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"若 m = n，两指针同时到达末尾变为 null\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"若 m ≠ n，两指针各移动 m+n 次后同时变为 null\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Python\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Solution\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getIntersectionNode\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"self, headA: ListNode, headB: ListNode\"\n        }), \") -\u003e ListNode:\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" headA \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"or\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" headB:\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"None\"\n        }), \"\\n\\n        pA, pB = headA, headB\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" pA != pB:\\n            pA = pA.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"next\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" pA \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" headB\\n            pB = pB.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"next\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" pB \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" headA\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" pA\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"C++\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Solution\"\n        }), \" {\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \":\\n    \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"ListNode *\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"getIntersectionNode\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(ListNode *headA, ListNode *headB)\"\n          }), \" \"]\n        }), \"{\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!headA || !headB) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"nullptr\"\n        }), \";\\n\\n        ListNode *pA = headA, *pB = headB;\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (pA != pB) {\\n            pA = pA ? pA-\u003enext : headB;\\n            pB = pB ? pB-\u003enext : headA;\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" pA;\\n    }\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"复杂度分析\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"时间复杂度：\"\n        }), \" O(m + n)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"空间复杂度：\"\n        }), \" O(1)，只使用两个指针\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      children: \"两种解法对比\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"解法\"\n          }), _jsx(_components.th, {\n            children: \"时间复杂度\"\n          }), _jsx(_components.th, {\n            children: \"空间复杂度\"\n          }), _jsx(_components.th, {\n            children: \"优点\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"哈希集合\"\n          }), _jsx(_components.td, {\n            children: \"O(m+n)\"\n          }), _jsx(_components.td, {\n            children: \"O(m)\"\n          }), _jsx(_components.td, {\n            children: \"思路简单直观\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"双指针\"\n          }), _jsx(_components.td, {\n            children: \"O(m+n)\"\n          }), _jsx(_components.td, {\n            children: \"O(1)\"\n          }), _jsx(_components.td, {\n            children: \"空间最优\"\n          })]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"title":"160. 相交链表","difficulty":"简单"},"__N_SSG":true},"page":"/problems/[slug]","query":{"slug":"160-intersection-of-two-linked-lists"},"buildId":"rOLg3E_DLBfZoa8jF2pXF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>